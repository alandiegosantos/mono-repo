package resolver

import (
	"fmt"
	"strings"
)

// imageSpec describes the differents parts of an image generated by
// rules_docker.
type imageSpec struct {
	// name is the name of the image.
	name string
	// imgTarball is the image in the `docker save` tarball format.
	imgTarball string
	// imgConfig if the config JSON file of the image.
	imgConfig string
	// digests is a list of files with the sha256 digests of the compressed
	// layers.
	digests []string
	// diffIDs is a list of files with the sha256 digests of the uncompressed
	// layers.
	diffIDs []string
	// compressedLayers are the paths to the compressed layer tarballs.
	compressedLayers []string
	// uncompressedLayers are the paths to the uncompressed layer tarballs.
	uncomressedLayers []string
}

// layers returns a list of strings that can be passed to the image reader in
// the compatiblity package of rules_docker to read the layers of an image in
// the format "va11,val2,val3,val4" where:
// val1 is the compressed layer tarball.
// val2 is the uncompressed layer tarball.
// val3 is the digest file.
// val4 is the diffID file.
func (s *imageSpec) layers() ([]string, error) {
	result := []string{}
	if len(s.digests) != len(s.diffIDs) || len(s.diffIDs) != len(s.compressedLayers) || len(s.compressedLayers) != len(s.uncomressedLayers) {
		return nil, fmt.Errorf("digest, diffID, compressed blobs & uncompressed blobs had unequal lengths for image %s, got %d, %d, %d, %d, want all of the lengths to be equal", s.name, len(s.digests), len(s.diffIDs), len(s.compressedLayers), len(s.uncomressedLayers))
	}
	for i, digest := range s.digests {
		diffID := s.diffIDs[i]
		compressedLayer := s.compressedLayers[i]
		uncompressedLayer := s.uncomressedLayers[i]
		result = append(result, fmt.Sprintf("%s,%s,%s,%s", compressedLayer, uncompressedLayer, digest, diffID))
	}
	return result, nil
}

// parseImageSpec parses the differents parts of a single docker image specified
// as string in the format "key1=val1;key2=val2" where the expected keys are:
// 1. "name": Name of the image.
// 2. "tarball": docker save tarball of the image.
// 3. "config": JSON config file of the image.
// 4. "diff_id": Files with sha256 digest of uncompressed layers.
// 5. "digest": Files with sha256 digest of compressed layers.
// 6. "compressed_layer": Path to compressed layer tarballs.
// 7. "uncompressed_layer": Path to uncompressed layer tarballs.
func parseImageSpec(spec string) (imageSpec, error) {
	result := imageSpec{}
	splitSpec := strings.Split(spec, ";")
	for _, s := range splitSpec {
		splitFields := strings.SplitN(s, "=", 2)
		if len(splitFields) != 2 {
			return imageSpec{}, fmt.Errorf("image spec item %q split by '=' into unexpected fields, got %d, want 2", s, len(splitFields))
		}
		switch splitFields[0] {
		case "name":
			result.name = splitFields[1]
		case "tarball":
			result.imgTarball = splitFields[1]
		case "config":
			result.imgConfig = splitFields[1]
		case "diff_id":
			result.diffIDs = strings.Split(splitFields[1], ",")
		case "digest":
			result.digests = strings.Split(splitFields[1], ",")
		case "compressed_layer":
			result.compressedLayers = strings.Split(splitFields[1], ",")
		case "uncompressed_layer":
			result.uncomressedLayers = strings.Split(splitFields[1], ",")
		default:
			return imageSpec{}, fmt.Errorf("unknown image spec field %q", splitFields[0])
		}
	}
	return result, nil
}
